var documenterSearchIndex = {"docs":
[{"location":"#![ClustForOpt-logo](assets/clust_for_opt_text.svg)-1","page":"Introduction","title":"(Image: ClustForOpt logo)","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"(Image: ) (Image: ) (Image: Build Status)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"ClustForOpt is a julia implementation of clustering methods for finding representative periods for optimization problems. A utilization in a scalable capacity expansion problem can be found in the package CEP.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The package has two main purposes: 1) Provide a simple process of clustering time-series input data, with clustered data output in a generalized type system 2) provide an interface between clustered data and optimization problem.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The package follows the clustering framework presented in Teichgraeber and Brandt, 2019. The package is actively developed, and new features are continuously added. For a reproducible version of the methods and data of the original paper by Teichgraeber and Brandt, 2019, please refer to branch v0.1-appl_energy-framework-comp.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"This package is developed by Holger Teichgraeber @holgerteichgraeber and Elias Kuepper @YoungFaithful.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"If you find ClustForOpt useful in your work, we kindly request that you cite the following paper (link):","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"  @article{Teichgraeber2019,\n  author = {Holger Teichgraeber and Adam Brandt},\n  title = {Clustering methods to find representative periods for the optimization of energy systems: An initial framework and comparison},\n  journal = {Applied Energy},\n  volume = {239},\n  pages = {1283–1293},\n  year = {2019},\n  doi = {https://doi.org/10.1016/j.apenergy.2019.02.012},\n  }","category":"page"},{"location":"#Installation-1","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"This package runs under julia v1.0 and higher. Install using:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"]\nadd https://github.com/holgerteichgraeber/ClustForOpt.jl.git","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"where ] opens the julia package manager.","category":"page"},{"location":"workflow/#Workflow-1","page":"Workflow","title":"Workflow","text":"","category":"section"},{"location":"workflow/#","page":"Workflow","title":"Workflow","text":"Generally, the workflow requires three steps:","category":"page"},{"location":"workflow/#","page":"Workflow","title":"Workflow","text":"load data\nclustering\noptimization","category":"page"},{"location":"workflow/#Example-Workflow-1","page":"Workflow","title":"Example Workflow","text":"","category":"section"},{"location":"workflow/#","page":"Workflow","title":"Workflow","text":"using ClustForOpt\n\n# load data (electricity price day ahead market)\nts_input_data, = load_timeseries_data(\"DAM\", \"GER\";K=365, T=24) #DAM\n\n# run standard kmeans clustering algorithm to cluster into 5 representative periods, with 1000 initial starting points\nclust_res = run_clust(ts_input_data;method=\"kmeans\",representation=\"centroid\",n_clust=5,n_init=1000)\n\n# battery operations optimization on the clustered data\nopt_res = run_opt(clust_res)","category":"page"},{"location":"load_data/#Load-Data-1","page":"Load Data","title":"Load Data","text":"","category":"section"},{"location":"load_data/#Load-Timeseries-Data-1","page":"Load Data","title":"Load Timeseries Data","text":"","category":"section"},{"location":"load_data/#","page":"Load Data","title":"Load Data","text":"load_timeseries_data() loads the data for a given application and region. Possible applications are","category":"page"},{"location":"load_data/#","page":"Load Data","title":"Load Data","text":"DAM: Day ahead market price data","category":"page"},{"location":"load_data/#","page":"Load Data","title":"Load Data","text":"Possible regions are:","category":"page"},{"location":"load_data/#","page":"Load Data","title":"Load Data","text":"GER: Germany\nCA: California","category":"page"},{"location":"load_data/#","page":"Load Data","title":"Load Data","text":"The optional input parameters to load_timeseries_data() are the number of periods K and the number of time steps per period T. By default, they are chosen such that they result in daily time slices.","category":"page"},{"location":"load_data/#","page":"Load Data","title":"Load Data","text":"load_timeseries_data","category":"page"},{"location":"load_data/#ClustForOpt.load_timeseries_data","page":"Load Data","title":"ClustForOpt.load_timeseries_data","text":"load_timeseriesdata(data_path::String; T-#Segments,years::Array{Int64,1}=# years to be selected for the time series, att::Array{String,1}=# attributes to be loaded)\n\nLoading all *.csv files in the folder or the file data_path\nThe *.csv files shall have the following structure and must have the same length:\n\nTimestamp Year [column names...]\n[iterator] [year] [values]\n\nThe first column should be called Timestamp if it contains a time iterator\nThe second column should be called Year and contains the corresponding year\nThe other columns can specify the single timeseries like specific geolocation.\nEach column in [file name].csv file will be added to the ClustData.data called \"[file name]-[column name]\"\nLoads all attributes if the att-Array is empty or only the ones specified in it\n\n\n\n\n\n","category":"function"},{"location":"load_data/#Example-loading-timeseries-data-1","page":"Load Data","title":"Example loading timeseries data","text":"","category":"section"},{"location":"load_data/#","page":"Load Data","title":"Load Data","text":"using ClustForOpt\n# laod ts-input-data\nts_input_data = load_timeseries_data(normpath(joinpath(@__DIR__,\"..\",\"..\",\"data\",\"TS_GER_1\")); T=24, years=[2016])\nusing Plots\nplot(ts_input_data.data[\"solar-germany\"], legend=false, linestyle=:dot, xlabel=\"Time [h]\", ylabel=\"Solar availability factor [%]\")\nsavefig(\"load_timeseries_data.svg\")","category":"page"},{"location":"load_data/#","page":"Load Data","title":"Load Data","text":"(Image: Plot)","category":"page"},{"location":"clust/#Clustering-1","page":"Clustering","title":"Clustering","text":"","category":"section"},{"location":"clust/#","page":"Clustering","title":"Clustering","text":"run_clust() takes the full data and gives a struct with the clustered data as the output.   ","category":"page"},{"location":"clust/#","page":"Clustering","title":"Clustering","text":"The input parameter n_clust determines the number of clusters,i.e., representative periods.","category":"page"},{"location":"clust/#Supported-clustering-methods-1","page":"Clustering","title":"Supported clustering methods","text":"","category":"section"},{"location":"clust/#","page":"Clustering","title":"Clustering","text":"The following combinations of clustering method and representations are supported by run_clust:","category":"page"},{"location":"clust/#","page":"Clustering","title":"Clustering","text":"Name method representation\nk-means clustering <kmeans> <centroid>\nk-means clustering with medoid representation <kmeans> <medoid>\nk-medoids clustering (partitional) <kmedoids> <medoid>\nk-medoids clustering (exact) [requires Gurobi] <kmedoids_exact> <medoid>\nhierarchical clustering with centroid representation <hierarchical> <centroid>\nhierarchical clustering with medoid representation <hierarchical> <medoid>","category":"page"},{"location":"clust/#","page":"Clustering","title":"Clustering","text":"For use of DTW barycenter averaging (DBA) and k-shape clustering on single-attribute data (e.g. electricity prices), please use branch v0.1-appl_energy-framework-comp.","category":"page"},{"location":"clust/#","page":"Clustering","title":"Clustering","text":"run_clust","category":"page"},{"location":"clust/#ClustForOpt.run_clust","page":"Clustering","title":"ClustForOpt.run_clust","text":"run_clust(data::ClustData;norm_op::String=\"zscore\",norm_scope::String=\"full\",method::String=\"kmeans\",representation::String=\"centroid\",n_clust::Int=5,n_init::Int=100,iterations::Int=300,save::String=\"\",attribute_weights::Dict{String,Float64}=Dict{String,Float64}(),get_all_clust_results::Bool=false,kwargs...)\n\nnormop: \"zscore\", \"01\"(not implemented yet) normscope: \"full\",\"sequence\",\"hourly\" method: \"kmeans\",\"kmedoids\",\"kmedoids_exact\",\"hierarchical\" representation: \"centroid\",\"medoid\"\n\n\n\n\n\nfunction runclust(datanormmerged::ClustDataMerged;                   method::String=\"kmeans\",                   representation::String=\"centroid\",                   nclust::Int=5,                   ninit::Int=100,                   iterations::Int=300,                   origk_ids::Array{Int64,1}=Array{Int64,1}(),                   kwargs...)\n\nmethod: \"kmeans\",\"kmedoids\",\"kmedoids_exact\",\"hierarchical\" representation: \"centroid\",\"medoid\"\n\n\n\n\n\nrun_clust(data::ClustData,n_clust_ar::Array{Int,1};norm_op::String=\"zscore\",norm_scope::String=\"full\",method::String=\"kmeans\",representation::String=\"centroid\",n_init::Int=100,iterations::Int=300,save::String=\"\",kwargs...)\n\nThis function is a wrapper function around runclust(). It runs multiple number of clusters k and returns an array of results. normop: \"zscore\", \"01\"(not implemented yet) normscope: \"full\",\"sequence\",\"hourly\" method: \"kmeans\",\"kmedoids\",\"kmedoidsexact\",\"hierarchical\" representation: \"centroid\",\"medoid\"\n\n\n\n\n\n","category":"function"},{"location":"clust/#Opt-Types-1","page":"Clustering","title":"Opt Types","text":"","category":"section"},{"location":"clust/#","page":"Clustering","title":"Clustering","text":"FullInputData\nClustData\nClustDataMerged\nClustResultAll\nClustResultBest\nClustResultSimple","category":"page"},{"location":"clust/#ClustForOpt.FullInputData","page":"Clustering","title":"ClustForOpt.FullInputData","text":"FullInputData\n\n\n\n\n\n","category":"type"},{"location":"clust/#ClustForOpt.ClustData","page":"Clustering","title":"ClustForOpt.ClustData","text":"  ClustData{region::String,K::Int,T::Int,data::Dict{String,Array},weights::Array{Float64},mean::Dict{String,Array},sdv::Dict{String,Array}} <: TSData\n\nregion: optional information to specify the region data belongs to\nK: number of periods\nT: time steps per period\ndata: Dictionary with an entry for each attribute [file name (e.g technology)]-[column name (e.g. location)], Each entry of the dictionary is a 2-dimensional time-steps T x periods K-Array holding the actual value\nweights: 1-dimensional periods K-Array with the absolute weight for each period. E.g. for a year of 365 days, sum(weights)=365\nmean: Dictionary with a entry for each attribute [file name (e.g technology)]-[column name (e.g. location)], Each entry of the dictionary is a 1-dimensional periods K-Array holding the shift of the mean\nsdv:  Dictionary with an entry for each attribute [file name (e.g technology)]-[column name (e.g. location)], Each entry of the dictionary is a 1-dimensional periods K-Array holding the standard deviation\ndelta_t: 2-dimensional time-steps T x periods K-Array with the temporal duration Δt for each timestep in [h]\nk_ids: 1-dimensional original periods I-Array with the information, which original period is represented by which period K. If an original period is not represented by any period within this ClustData the entry will be 0.\n\n\n\n\n\n","category":"type"},{"location":"clust/#ClustForOpt.ClustDataMerged","page":"Clustering","title":"ClustForOpt.ClustDataMerged","text":"ClustDataMerged\n\n\n\n\n\n","category":"type"},{"location":"clust/#ClustForOpt.ClustResultAll","page":"Clustering","title":"ClustForOpt.ClustResultAll","text":"ClustResultAll\n\n\n\n\n\n","category":"type"},{"location":"clust/#ClustForOpt.ClustResultBest","page":"Clustering","title":"ClustForOpt.ClustResultBest","text":"ClustResultBest\n\n\n\n\n\n","category":"type"},{"location":"clust/#ClustForOpt.ClustResultSimple","page":"Clustering","title":"ClustForOpt.ClustResultSimple","text":"ClustResultSimple\n\n\n\n\n\n","category":"type"},{"location":"clust/#Example-running-clustering-1","page":"Clustering","title":"Example running clustering","text":"","category":"section"},{"location":"clust/#","page":"Clustering","title":"Clustering","text":"using ClustForOpt\n# load ts-input-data\nts_input_data = load_timeseries_data(normpath(joinpath(@__DIR__,\"..\",\"..\",\"data\",\"TS_GER_1\")); T=24, years=[2016])\nts_clust_data = run_clust(ts_input_data).best_results\nusing Plots\nplot(ts_clust_data.data[\"solar-germany\"], legend=false, linestyle=:solid, width=3, xlabel=\"Time [h]\", ylabel=\"Solar availability factor [%]\")\nsavefig(\"clust.svg\")","category":"page"},{"location":"clust/#","page":"Clustering","title":"Clustering","text":"(Image: Plot)","category":"page"},{"location":"opt/#Optimization-1","page":"Optimization","title":"Optimization","text":"","category":"section"},{"location":"opt/#","page":"Optimization","title":"Optimization","text":"The function run_opt() runs the optimization problem and gives as an output a struct that contains optimal objective function value, decision variables, and additional info. The run_opt() function infers the optimization problem type from the input data. See the example folder for further details.","category":"page"}]
}
